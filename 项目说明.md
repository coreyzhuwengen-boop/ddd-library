# DDD Library 项目说明文档

## 项目概述

这是一个基于**领域驱动设计（Domain-Driven Design, DDD）**的图书馆管理系统示例项目。该项目展示了如何将 DDD 理论、事件驱动架构、六边形架构等现代软件设计理念应用到实际代码中，是一个优秀的教学和参考项目。

项目使用真实业务需求驱动开发，结合了以下技术和方法论：
- **领域驱动设计（DDD）**
- **行为驱动开发（BDD）**
- **事件风暴（Event Storming）**
- **用户故事映射（User Story Mapping）**

---

## 技术栈

| 技术 | 版本/说明 |
|------|----------|
| **编程语言** | Java 11 |
| **构建工具** | Maven |
| **应用框架** | Spring Boot 2.2.0 |
| **数据库** | H2（内存数据库） |
| **测试框架** | Spock Framework（基于 Groovy） |
| **函数式编程库** | Vavr 0.9.2 |
| **架构测试工具** | ArchUnit 0.9.3 |
| **代码生成工具** | Lombok 1.18.4 |
| **监控** | Prometheus + Grafana + Micrometer |

---

## 项目结构

### 整体架构

项目采用**模块化单体架构（Modular Monolith）**，按有界上下文（Bounded Context）组织代码：

```
library/
├── catalogue/          # 图书目录上下文（CRUD风格）
├── commons/            # 公共组件
│   ├── aggregates/     # 聚合根基类
│   ├── commands/       # 命令结果
│   └── events/         # 领域事件基础设施
└── lending/           # 借阅上下文（六边形架构）
    ├── book/          # 图书聚合
    ├── patron/        # 读者聚合
    ├── dailysheet/    # 每日工作表（读模型）
    ├── patronprofile/ # 读者档案（读模型）
    └── librarybranch/ # 图书馆分馆
```

### 目录结构详解

```
src/
├── main/
│   ├── java/
│   │   └── io/pillopl/library/
│   │       ├── LibraryApplication.java    # 应用入口
│   │       ├── catalogue/                 # 图书目录模块
│   │       ├── commons/                   # 公共组件
│   │       └── lending/                   # 借阅模块
│   └── resources/
│       ├── application.yml                 # 应用配置
│       └── *.sql                           # 数据库初始化脚本
├── test/                                   # 单元测试
│   └── groovy/
└── integration-test/                       # 集成测试
    └── groovy/
```

---

## 核心业务领域

### 1. 图书目录（Catalogue）上下文

**职责**：管理图书馆的图书目录和图书实例

**特点**：
- 采用 CRUD 风格的简单架构（无复杂业务逻辑）
- 管理图书基本信息：ISBN、标题、价格
- 支持添加图书实例，每个实例可以是流通（Circulating）或限制（Restricted）类型

**核心实体**：
- `Book`：图书
- `BookInstance`：图书实例
- `ISBN`：国际标准书号

### 2. 借阅（Lending）上下文

**职责**：处理图书借阅、预约、归还等核心业务逻辑

**架构**：采用六边形架构（Hexagonal Architecture）

#### 2.1 读者聚合（Patron）

**业务规则**：
- **读者类型**：
  - 普通读者（Regular）：最多可预约 5 本书
  - 研究员（Researcher）：无预约数量限制
- **预约限制**：
  - 限制类图书只能被研究员预约
  - 普通读者不能预约限制类图书
  - 如果读者在某个分馆有超过 2 本逾期借阅，则不能在该分馆预约新书
- **预约类型**：
  - 开放型预约（Open-ended）：直到借出才完成，只有研究员可以使用
  - 封闭型预约（Close-ended）：有固定天数限制，到期未借出则过期

**核心类**：
- `Patron`：读者聚合根
- `PatronHolds`：读者预约集合
- `OverdueCheckouts`：逾期借阅
- `PlacingOnHoldPolicy`：预约策略（函数式接口）

#### 2.2 图书聚合（Book）

**状态模型**（使用类型系统表示）：
```
AvailableBook → BookOnHold → CheckedOutBook
```

**特点**：
- 通过不同的类型（`AvailableBook`、`BookOnHold`、`CheckedOutBook`）表示状态
- 编译期保证状态转换的正确性
- 只能对 `AvailableBook` 执行预约操作
- 只能对 `BookOnHold` 执行取消预约操作

**核心类**：
- `Book`：图书接口
- `AvailableBook`：可借阅状态
- `BookOnHold`：已预约状态
- `CheckedOutBook`：已借出状态

#### 2.3 每日工作表（DailySheet）

**职责**：读模型，用于查询和管理日常业务

**功能**：
- 跟踪即将过期的预约（`HoldsToExpireSheet`）
- 跟踪逾期借阅（`CheckoutsToOverdueSheet`）
- 支持每日批量处理任务

#### 2.4 读者档案（PatronProfile）

**职责**：读模型，供读者查看个人信息

**功能**：
- 查看当前预约（未取消、未过期）
- 查看当前借阅（包括逾期）
- 提供 REST API 接口

---

## 设计特点

### 1. 六边形架构（Hexagonal Architecture）

**分层结构**：
- **model**：领域模型层（纯业务逻辑，无框架依赖）
- **application**：应用服务层（编排领域对象）
- **infrastructure**：基础设施层（Spring、数据库、外部服务）
- **web**：Web 层（REST API，仅部分模块有）

**优势**：
- 领域逻辑可独立测试，无需模拟依赖
- 基础设施可替换，不影响核心业务
- 清晰的依赖方向：外层依赖内层

### 2. 事件驱动架构（Event-Driven Architecture）

**事件通信**：
- 聚合之间通过领域事件（Domain Event）通信
- 降低聚合间的耦合度

**一致性模型**：
- **立即一致性（Immediate Consistency）**：
  - 使用 Spring ApplicationEventPublisher
  - 事件发布后立即处理
  - 适合简单场景

- **最终一致性（Eventual Consistency）**：
  - 事件存储后异步处理
  - 使用 `StoreAndForwardDomainEventPublisher`
  - 支持消息队列等基础设施

**事件示例**：
- `BookPlacedOnHold`：图书被预约
- `BookHoldCanceled`：预约被取消
- `BookCheckedOut`：图书被借出
- `MaximumNumberOfHoldsReached`：达到最大预约数

### 3. 函数式编程风格

#### 3.1 不可变对象
- 所有领域对象都是不可变的（使用 Lombok `@Value`）
- 状态变更返回新对象而非修改现有对象

#### 3.2 单子（Monads）
使用 Vavr 库提供的单子处理不同场景：

- **Option**：处理可能为空的值
  ```java
  Option<Book> findBy(BookId bookId)
  ```

- **Either**：处理可能失败的操作
  ```java
  Either<BookHoldFailed, BookPlacedOnHoldEvents> placeOnHold(AvailableBook book)
  ```

- **Try**：处理可能抛出异常的操作
  ```java
  Try<Result> placeOnHold(PlaceOnHoldCommand command)
  ```

#### 3.3 模式匹配（Pattern Matching）
使用模式匹配替代 if/else 或 switch：

```java
return Match(book).of(
    Case($(instanceOf(AvailableBook.class)), availableBook -> ...),
    Case($(instanceOf(BookOnHold.class)), bookOnHold -> ...),
    Case($(), () -> book)
);
```

#### 3.4 纯函数
- 业务操作建模为纯函数（函数式接口）
- 实现放在基础设施层，包含副作用（I/O、数据库等）

### 4. 类型系统设计

**状态表示**：
- 不使用枚举 + 状态字段
- 使用不同的类型表示不同的状态
- 编译器保证业务规则

**示例**：
```java
// 错误方式：运行时检查
public Either<BookHoldFailed, BookPlacedOnHoldEvents> placeOnHold(Book book) {
    if (book.status == AVAILABLE) { ... }
}

// 正确方式：编译期保证
public Either<BookHoldFailed, BookPlacedOnHoldEvents> placeOnHold(AvailableBook book) {
    // 只能传入 AvailableBook，无需检查状态
}
```

### 5. CQRS（命令查询职责分离）

**写模型**（命令端）：
- `Patron`：处理预约、借阅等命令
- `Book`：处理状态变更命令

**读模型**（查询端）：
- `DailySheet`：每日工作表查询
- `PatronProfile`：读者档案查询

**优势**：
- 读写模型可独立优化
- 读模型可针对查询场景优化
- 支持复杂查询而不影响写模型

### 6. 无 ORM 设计

**不使用 JPA/Hibernate 的原因**：
- 不需要延迟加载（聚合较小）
- 不需要缓存（业务特性决定）
- 不需要脏检查（使用事件驱动）
- 需要更精确的 SQL 控制

**使用的技术**：
- Spring Data JDBC：轻量级 ORM
- JdbcTemplate：直接 SQL 操作
- 手动映射：领域模型 ↔ 数据库实体

### 7. 架构测试（ArchUnit）

使用 ArchUnit 验证架构约束：

```java
// 确保领域模型不依赖基础设施
@ArchTest
public static final ArchRule model_should_not_depend_on_infrastructure =
    noClasses()
        .that()
        .resideInAPackage("..model..")
        .should()
        .dependOnClassesThat()
        .resideInAPackage("..infrastructure..");

// 确保领域模型不依赖 Spring
@ArchTest
public static final ArchRule model_should_not_depend_on_spring =
    noClasses()
        .that()
        .resideInAPackage("..model..")
        .should()
        .dependOnClassesThat()
        .resideInAPackage("org.springframework..");
```

---

## 业务规则总结

### 预约规则（Placing on Hold）

1. **限制类图书策略**：只有研究员可以预约限制类图书
2. **逾期借阅策略**：如果读者在某个分馆有超过 2 本逾期借阅，不能在该分馆预约
3. **最大预约数策略**：普通读者最多预约 5 本书
4. **开放型预约策略**：只有研究员可以创建开放型预约

### 借阅规则

- 图书最多可借阅 60 天
- 借出后预约自动完成
- 归还时如果逾期，会取消逾期记录

### 过期规则

- 封闭型预约在固定天数后过期（每日检查）
- 开放型预约不会过期
- 借阅超过 60 天视为逾期（每日检查）

---

## 测试策略

### 1. 单元测试
- 使用 Spock Framework（Groovy）
- 测试领域逻辑，无需模拟依赖
- BDD 风格：given-when-then

### 2. 集成测试
- 测试聚合间协作
- 测试事件传播
- 验证数据库状态

### 3. 架构测试
- 使用 ArchUnit 验证架构约束
- 确保依赖方向正确
- 防止架构腐化

### 4. 测试 DSL
项目提供了领域特定的测试 DSL，使测试代码更接近业务语言：

```groovy
def 'should make book available when hold canceled'() {
    given:
        BookDSL bookOnHold = aCirculatingBook() with anyBookId() 
            locatedIn anyBranch() placedOnHoldBy anyPatron()
    when:
        AvailableBook availableBook = the bookOnHold reactsTo bookHoldCanceledEvent
    then:
        availableBook.bookId == bookOnHold.bookId
}
```

---

## 部署与运行

### 前置要求

- Java 11
- Maven 3.6+

### 快速启动

```bash
# 运行应用
mvn spring-boot:run

# 构建 JAR
mvn clean package

# 运行测试
mvn test

# 运行集成测试
mvn verify
```

### Docker 部署

```bash
# 构建镜像（包含编译）
docker build -t spring/library -f Dockerfile.build .

# 运行容器
docker run -ti --rm --name spring-library -p 8080:8080 spring/library
```

### 完整监控栈

```bash
# 启动应用 + Prometheus + Grafana
docker-compose up
```

访问地址：
- 应用：http://localhost:8080
- Prometheus：http://localhost:9090
- Grafana：http://localhost:3000
- 指标端点：http://localhost:8080/actuator/prometheus

---

## 项目文档

项目包含丰富的设计文档：

- **`docs/big-picture.md`**：大图景事件风暴，识别业务流程
- **`docs/design-level.md`**：设计级事件风暴，细化实现细节
- **`docs/example-mapping.md`**：示例映射，将用户故事转化为测试用例
- **`docs/c4/component-diagram.png`**：组件架构图

---

## 设计原则

### 1. 模型-代码一致性
- 代码结构反映领域模型
- 类名、方法名使用领域语言（Ubiquitous Language）
- 业务规则在代码中清晰可见

### 2. 架构-代码一致性
- 包结构反映有界上下文
- 每个上下文有独立的 Spring 应用上下文
- 便于未来拆分为微服务

### 3. 延迟重要决策
- 支持立即一致性和最终一致性切换
- 基础设施可替换
- 架构支持演进

### 4. 最小化耦合
- 聚合间通过事件通信
- 领域模型不依赖框架
- 基础设施依赖领域，而非相反

---

## 项目价值

### 1. 教学价值
- 完整的 DDD 实践示例
- 从事件风暴到代码实现的完整流程
- 多种设计模式的综合应用

### 2. 参考价值
- 模块化单体架构参考
- 六边形架构实现参考
- 事件驱动架构参考
- CQRS 实现参考

### 3. 技术价值
- 函数式编程在 Java 中的应用
- 类型系统设计
- 架构测试实践
- 无 ORM 的数据访问模式

### 4. 演进价值
- 支持从单体到微服务的演进
- 模块边界清晰，便于拆分
- 独立的应用上下文，降低运行时耦合

---

## 学习路径建议

1. **理解业务领域**：阅读 `README.md` 和 `docs/` 目录下的文档
2. **理解架构**：查看包结构和组件图
3. **理解领域模型**：从 `Patron` 和 `Book` 聚合开始
4. **理解事件驱动**：查看事件发布和处理的流程
5. **理解测试**：查看测试代码，理解 BDD 和 DSL
6. **实践扩展**：尝试添加新功能，保持架构一致性

---

## 参考资料

项目参考了以下经典书籍和资源：

1. **Introducing EventStorming** - Alberto Brandolini
2. **Domain Modelling Made Functional** - Scott Wlaschin
3. **Software Architecture for Developers** - Simon Brown
4. **Clean Architecture** - Robert C. Martin
5. **Domain-Driven Design** - Eric Evans

---

## 贡献指南

项目仍在持续改进中，欢迎贡献：
- 提交 Issue 报告问题
- 提交 Pull Request 改进代码
- 完善文档和示例

---

## 许可证

查看 `LICENSE` 文件了解许可证信息。

---

**最后更新**：2024年

**项目地址**：https://github.com/ddd-by-examples/library

